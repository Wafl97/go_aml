package fsm

import (
	"fmt"
	"os"
	"path"

	"github.com/Wafl97/go_aml/util/logger"
)

const GENERATOR_VERSION = "v0.2.0"

var glog logger.Logger

const modFile = `// Generated by AML %s
module srcgen

go 1.21.6
`

func Generate(model *FiniteStateMachine) {
	glog := logger.New("GENERATOR")
	glog.Infof("Generating code ...")
	os.MkdirAll("srcgen", os.ModeDir)

	generateFile(path.Join("srcgen", "go.mod"), fmt.Sprintf(modFile, GENERATOR_VERSION))
	generateFile(path.Join("srcgen", model.GetModelName()+".go"), GenerateCode(model))

	glog.Info("Generation complete")
}

func generateFile(fileName, fileContent string) {
	file, err := os.Create(fileName)
	if err != nil {
		glog.Error(err.Error())
	}
	file.Write([]byte(fileContent))
}

const codeStructure string = `/* Generated by AML %s */
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"strings"
)

type (
	State      int
	Transition struct {
		condition      func() bool
		resultingState State
		function       func()
	}
	StateNode struct {
		name                 string
		autoComputation      func(event string)
		autoEventTransitions []Transition
		transitions          map[string][]Transition
	}
)

var ( /* VARIABLES */
%s)

const ( /* STATES */
	TERMINATION_STATE State = -1
%s)

var STATES []StateNode = []StateNode{
%s}

var CURRENT_STATE *StateNode = &STATES[STATE_%s]
	
func main() {
	reader := bufio.NewReader(os.Stdin)
	for {
		fmt.Printf("State = %%s\n", CURRENT_STATE.name)
		switch event, err := reader.ReadString('\n'); err {
		case nil:
			handleEvent(event)
		case io.EOF:
			os.Exit(0)
		default:
			fmt.Print(err.Error())
			os.Exit(1)
		}
	}
}

func handleEvent(event string) {
	event = strings.TrimSpace(event)
	state, success := CURRENT_STATE.transitions[event]
	if !success {
		runAutoEvents(event)
		return
	}
	for _, transition := range state {
		if transition.condition == nil || transition.condition() {
			applyTransition(&transition)
			return
		}
	}
	runAutoEvents(event)
}

func applyTransition(transition *Transition) {
	switch transition.resultingState {
	case TERMINATION_STATE:
		fmt.Println("Terminating")
		os.Exit(0)
	default:
		CURRENT_STATE = &STATES[transition.resultingState]
		if transition.function != nil {
			transition.function()
		}
	}
}

func runAutoEvents(event string) {
	if CURRENT_STATE.autoComputation != nil {
		CURRENT_STATE.autoComputation(event)
	}
	for _, autoTransition := range CURRENT_STATE.autoEventTransitions {
		if autoTransition.condition != nil && !autoTransition.condition() {
			continue
		}
		applyTransition(&autoTransition)
	}
}
`

func GenerateCode(model *FiniteStateMachine) string {
	var variables string
	for varName, varValue := range model.variables.ints {
		variables += fmt.Sprintf("\t%s = %v\n", varName, varValue)
	}
	for varName, varValue := range model.variables.floats {
		variables += fmt.Sprintf("\t%s = %v\n", varName, varValue)
	}
	for varName, varValue := range model.variables.bools {
		variables += fmt.Sprintf("\t%s = %v\n", varName, varValue)
	}
	for varName, varValue := range model.variables.strings {
		variables += fmt.Sprintf("\t%s = %v\n", varName, varValue)
	}
	var states string
	stateCount := 0
	var transitions string
	for stateName, state := range model.states {
		states += fmt.Sprintf("\tSTATE_%s State = %d\n", stateName, stateCount)
		var defaultComputation string
		if len(state.defaultComputations.Computations) == 0 {
			defaultComputation = "nil"
		} else {
			defaultComputation = state.defaultComputations.Generate()
		}
		var autoEvents string = ""
		for _, autoEvent := range state.autoEvents {
			var resultState string
			switch autoEvent.terminate2 {
			case true:
				resultState = "TERMINATION_STATE"
			case false:
				resultState = fmt.Sprintf("STATE_%s", autoEvent.resultingState)
			}
			autoEvents += fmt.Sprintf("\t\t\t{%s, %s, %s},\n",
				autoEvent.conditions.Generate(),
				resultState,
				autoEvent.computations.Generate(),
			)
		}
		transitions += fmt.Sprintf("\t{\"%s\",\n\t\t%s,\n\t\t[]Transition{ /* AUTO-EVENTS */\n%s\t\t},\n\t\tmap[string][]Transition{ /* STATE_%s */\n",
			stateName,
			defaultComputation,
			autoEvents,
			stateName)
		for event, edges := range state.GetTransitions() {
			transitions += fmt.Sprintf("\t\t\t\"%s\": {\n", event)
			for _, edge := range edges {
				var resultState string
				switch edge.terminate2 {
				case true:
					resultState = "TERMINATION_STATE"
				case false:
					resultState = fmt.Sprintf("STATE_%s", *edge.resultingState)
				}
				transitions += fmt.Sprintf("\t\t\t\t{%s, %s, %s}, /* %s */\n",
					edge.condition2.Generate(),
					resultState,
					edge.computation2.Generate(),
					edge.metaData.rawLine)
			}
			transitions += "\t\t\t},\n"
		}
		transitions += "\t\t},\n\t},\n"
		stateCount++
	}
	initialState := model.currentState.GetName()
	return fmt.Sprintf(codeStructure, GENERATOR_VERSION, variables, states, transitions, initialState)
}
